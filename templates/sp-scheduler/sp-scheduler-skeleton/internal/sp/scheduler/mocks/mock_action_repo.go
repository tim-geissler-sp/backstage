// Code generated by MockGen. DO NOT EDIT.
// Source: internal/sp/scheduler/scheduler.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"
	time "time"

	gomock "github.com/golang/mock/gomock"
	scheduler "github.com/sailpoint/sp-scheduler/internal/sp/scheduler"
)

// MockActionRepo is a mock of ActionRepo interface.
type MockActionRepo struct {
	ctrl     *gomock.Controller
	recorder *MockActionRepoMockRecorder
}

// MockActionRepoMockRecorder is the mock recorder for MockActionRepo.
type MockActionRepoMockRecorder struct {
	mock *MockActionRepo
}

// NewMockActionRepo creates a new mock instance.
func NewMockActionRepo(ctrl *gomock.Controller) *MockActionRepo {
	mock := &MockActionRepo{ctrl: ctrl}
	mock.recorder = &MockActionRepoMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockActionRepo) EXPECT() *MockActionRepoMockRecorder {
	return m.recorder
}

// CountAll mocks base method.
func (m *MockActionRepo) CountAll(ctx context.Context) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "CountAll", ctx)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// CountAll indicates an expected call of CountAll.
func (mr *MockActionRepoMockRecorder) CountAll(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CountAll", reflect.TypeOf((*MockActionRepo)(nil).CountAll), ctx)
}

// DeleteAllByTenantID mocks base method.
func (m *MockActionRepo) DeleteAllByTenantID(ctx context.Context, tenantID scheduler.TenantID) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAllByTenantID", ctx, tenantID)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAllByTenantID indicates an expected call of DeleteAllByTenantID.
func (mr *MockActionRepoMockRecorder) DeleteAllByTenantID(ctx, tenantID interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllByTenantID", reflect.TypeOf((*MockActionRepo)(nil).DeleteAllByTenantID), ctx, tenantID)
}

// DeleteAllByTenantIDAndMeta mocks base method.
func (m *MockActionRepo) DeleteAllByTenantIDAndMeta(ctx context.Context, tenantID scheduler.TenantID, meta map[string]interface{}) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteAllByTenantIDAndMeta", ctx, tenantID, meta)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteAllByTenantIDAndMeta indicates an expected call of DeleteAllByTenantIDAndMeta.
func (mr *MockActionRepoMockRecorder) DeleteAllByTenantIDAndMeta(ctx, tenantID, meta interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteAllByTenantIDAndMeta", reflect.TypeOf((*MockActionRepo)(nil).DeleteAllByTenantIDAndMeta), ctx, tenantID, meta)
}

// DeleteByID mocks base method.
func (m *MockActionRepo) DeleteByID(ctx context.Context, id scheduler.ActionID) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "DeleteByID", ctx, id)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// DeleteByID indicates an expected call of DeleteByID.
func (mr *MockActionRepoMockRecorder) DeleteByID(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "DeleteByID", reflect.TypeOf((*MockActionRepo)(nil).DeleteByID), ctx, id)
}

// FindAllByTenantID mocks base method.
func (m *MockActionRepo) FindAllByTenantID(ctx context.Context, tenantID scheduler.TenantID, limit, offset int) ([]*scheduler.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAllByTenantID", ctx, tenantID, limit, offset)
	ret0, _ := ret[0].([]*scheduler.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAllByTenantID indicates an expected call of FindAllByTenantID.
func (mr *MockActionRepoMockRecorder) FindAllByTenantID(ctx, tenantID, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllByTenantID", reflect.TypeOf((*MockActionRepo)(nil).FindAllByTenantID), ctx, tenantID, limit, offset)
}

// FindAllByTenantIDAndMeta mocks base method.
func (m *MockActionRepo) FindAllByTenantIDAndMeta(ctx context.Context, tenantID scheduler.TenantID, meta map[string]interface{}, limit, offset int) ([]*scheduler.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindAllByTenantIDAndMeta", ctx, tenantID, meta, limit, offset)
	ret0, _ := ret[0].([]*scheduler.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindAllByTenantIDAndMeta indicates an expected call of FindAllByTenantIDAndMeta.
func (mr *MockActionRepoMockRecorder) FindAllByTenantIDAndMeta(ctx, tenantID, meta, limit, offset interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindAllByTenantIDAndMeta", reflect.TypeOf((*MockActionRepo)(nil).FindAllByTenantIDAndMeta), ctx, tenantID, meta, limit, offset)
}

// FindByID mocks base method.
func (m *MockActionRepo) FindByID(ctx context.Context, id scheduler.ActionID) (*scheduler.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "FindByID", ctx, id)
	ret0, _ := ret[0].(*scheduler.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// FindByID indicates an expected call of FindByID.
func (mr *MockActionRepoMockRecorder) FindByID(ctx, id interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindByID", reflect.TypeOf((*MockActionRepo)(nil).FindByID), ctx, id)
}

// Save mocks base method.
func (m *MockActionRepo) Save(ctx context.Context, a *scheduler.Action) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Save", ctx, a)
	ret0, _ := ret[0].(error)
	return ret0
}

// Save indicates an expected call of Save.
func (mr *MockActionRepoMockRecorder) Save(ctx, a interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Save", reflect.TypeOf((*MockActionRepo)(nil).Save), ctx, a)
}

// TriggerActionsPastDeadline mocks base method.
func (m *MockActionRepo) TriggerActionsPastDeadline(ctx context.Context, deadline time.Time, max int64, retryLimit int, eventPublisher scheduler.EventPublisher) (int64, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "TriggerActionsPastDeadline", ctx, deadline, max, retryLimit, eventPublisher)
	ret0, _ := ret[0].(int64)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// TriggerActionsPastDeadline indicates an expected call of TriggerActionsPastDeadline.
func (mr *MockActionRepoMockRecorder) TriggerActionsPastDeadline(ctx, deadline, max, retryLimit, eventPublisher interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "TriggerActionsPastDeadline", reflect.TypeOf((*MockActionRepo)(nil).TriggerActionsPastDeadline), ctx, deadline, max, retryLimit, eventPublisher)
}

// MockEventPublisher is a mock of EventPublisher interface.
type MockEventPublisher struct {
	ctrl     *gomock.Controller
	recorder *MockEventPublisherMockRecorder
}

// MockEventPublisherMockRecorder is the mock recorder for MockEventPublisher.
type MockEventPublisherMockRecorder struct {
	mock *MockEventPublisher
}

// NewMockEventPublisher creates a new mock instance.
func NewMockEventPublisher(ctrl *gomock.Controller) *MockEventPublisher {
	mock := &MockEventPublisher{ctrl: ctrl}
	mock.recorder = &MockEventPublisherMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockEventPublisher) EXPECT() *MockEventPublisherMockRecorder {
	return m.recorder
}

// BulkPublish mocks base method.
func (m *MockEventPublisher) BulkPublish(ctx context.Context, actions []*scheduler.Action) ([]scheduler.Action, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "BulkPublish", ctx, actions)
	ret0, _ := ret[0].([]scheduler.Action)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// BulkPublish indicates an expected call of BulkPublish.
func (mr *MockEventPublisherMockRecorder) BulkPublish(ctx, actions interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "BulkPublish", reflect.TypeOf((*MockEventPublisher)(nil).BulkPublish), ctx, actions)
}
